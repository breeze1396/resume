new class{constructor(){this.observer=null,this.loadedImages=new Set}init(){this.setupIntersectionObserver(),this.observeImages()}setupIntersectionObserver(){this.observer=new IntersectionObserver(e=>{e.forEach(e=>{e.isIntersecting&&this.loadImage(e.target)})},{root:null,rootMargin:"50px",threshold:.01})}observeImages(){document.querySelectorAll("img[data-src]").forEach(e=>this.observer.observe(e))}loadImage(e){if(this.loadedImages.has(e))return;const t=e.getAttribute("data-src"),s=e.getAttribute("data-src-highres");if(!t)return;const r=e.closest(".project-image-container")||e.parentElement;r&&r.classList.add("loading");const a=new Image;a.onload=()=>{if(e.src=t,e.removeAttribute("data-src"),this.loadedImages.add(e),r&&r.classList.remove("loading"),s){e.setAttribute("data-highres-loaded","false");const t=new Image;t.onload=()=>{e.setAttribute("data-highres-loaded","true"),e.setAttribute("data-highres-src",s)},t.src=s}this.observer.unobserve(e)},a.onerror=()=>{r&&(r.classList.remove("loading"),r.classList.add("error"))},a.src=t}async compressImage(e,t=800,s=.8){return new Promise((r,a)=>{const o=new FileReader;o.onload=e=>{const o=new Image;o.onload=()=>{const e=document.createElement("canvas");let a=o.width,i=o.height;a>t&&(i=i*t/a,a=t),e.width=a,e.height=i,e.getContext("2d").drawImage(o,0,0,a,i),e.toBlob(e=>{r(e)},"image/jpeg",s)},o.onerror=a,o.src=e.target.result},o.onerror=a,o.readAsDataURL(e)})}addImage(e){this.observer&&e.hasAttribute("data-src")&&this.observer.observe(e)}removeImage(e){this.observer&&(this.observer.unobserve(e),this.loadedImages.delete(e))}destroy(){this.observer&&this.observer.disconnect(),this.loadedImages.clear()}};